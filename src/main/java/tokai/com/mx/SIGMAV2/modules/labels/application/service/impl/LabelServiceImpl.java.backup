package tokai.com.mx.SIGMAV2.modules.labels.application.service.impl;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tokai.com.mx.SIGMAV2.modules.inventory.infrastructure.persistence.JpaWarehouseRepository;
import tokai.com.mx.SIGMAV2.modules.inventory.infrastructure.persistence.JpaInventoryStockRepository;
import tokai.com.mx.SIGMAV2.modules.inventory.infrastructure.persistence.JpaProductRepository;
import tokai.com.mx.SIGMAV2.modules.inventory.infrastructure.persistence.ProductEntity;
import tokai.com.mx.SIGMAV2.modules.inventory.infrastructure.persistence.WarehouseEntity;
import tokai.com.mx.SIGMAV2.modules.inventory.infrastructure.persistence.entity.InventoryStockEntity;
import tokai.com.mx.SIGMAV2.modules.labels.application.dto.*;
import tokai.com.mx.SIGMAV2.modules.labels.application.dto.GenerateBatchListDTO.ProductBatchDTO;
import tokai.com.mx.SIGMAV2.modules.labels.application.dto.reports.*;
import tokai.com.mx.SIGMAV2.modules.labels.application.service.LabelService;
import tokai.com.mx.SIGMAV2.modules.labels.application.service.JasperLabelPrintService;
import tokai.com.mx.SIGMAV2.modules.labels.domain.model.LabelGenerationBatch;
import tokai.com.mx.SIGMAV2.modules.labels.domain.model.LabelPrint;
import tokai.com.mx.SIGMAV2.modules.labels.domain.model.LabelRequest;
import tokai.com.mx.SIGMAV2.modules.labels.domain.model.Label;
import tokai.com.mx.SIGMAV2.modules.labels.domain.model.LabelCountEvent;
import tokai.com.mx.SIGMAV2.modules.labels.domain.model.LabelCancelled;
import tokai.com.mx.SIGMAV2.modules.labels.infrastructure.adapter.LabelsPersistenceAdapter;
import tokai.com.mx.SIGMAV2.modules.labels.infrastructure.persistence.JpaLabelRequestRepository;
import tokai.com.mx.SIGMAV2.modules.labels.application.exception.LabelNotFoundException;
import tokai.com.mx.SIGMAV2.modules.labels.application.exception.InvalidLabelStateException;
import tokai.com.mx.SIGMAV2.modules.labels.application.exception.PermissionDeniedException;
import tokai.com.mx.SIGMAV2.modules.labels.application.exception.DuplicateCountException;
import tokai.com.mx.SIGMAV2.modules.labels.application.exception.CountSequenceException;
import tokai.com.mx.SIGMAV2.modules.labels.domain.exception.LabelAlreadyCancelledException;
import tokai.com.mx.SIGMAV2.modules.warehouse.application.service.WarehouseAccessService;
import tokai.com.mx.SIGMAV2.modules.users.infrastructure.persistence.JpaUserRepository;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class LabelServiceImpl implements LabelService {

    private final LabelsPersistenceAdapter persistence;
    private final WarehouseAccessService warehouseAccessService;
    private final JpaProductRepository productRepository;
    private final JpaWarehouseRepository warehouseRepository;
    private final JpaInventoryStockRepository inventoryStockRepository;
    private final JpaLabelRequestRepository labelRequestRepository;
    private final JasperLabelPrintService jasperLabelPrintService;
    private final JpaUserRepository userRepository;
    private final tokai.com.mx.SIGMAV2.modules.labels.infrastructure.persistence.JpaLabelRepository jpaLabelRepository;
    private final tokai.com.mx.SIGMAV2.modules.labels.infrastructure.persistence.JpaLabelCancelledRepository jpaLabelCancelledRepository;
    private final tokai.com.mx.SIGMAV2.modules.labels.infrastructure.persistence.JpaLabelCountEventRepository jpaLabelCountEventRepository;
    private final tokai.com.mx.SIGMAV2.modules.labels.infrastructure.persistence.JpaLabelPrintRepository jpaLabelPrintRepository;

    @Override
    @Transactional
    public void requestLabels(LabelRequestDTO dto, Long userId, String userRole) {
        // Validar acceso al almacén
        warehouseAccessService.validateWarehouseAccess(userId, dto.getWarehouseId(), userRole);

        // REGLA DE NEGOCIO: Validar que la cantidad sea numérica entera (ya validado por DTO)
        // El DTO debe tener validación @Min(0) o similar

        // Buscar si ya existe una solicitud para este producto/almacén/periodo
        Optional<LabelRequest> existingRequest = persistence.findByProductWarehousePeriod(
            dto.getProductId(),
            dto.getWarehouseId(),
            dto.getPeriodId()
        );

        // REGLA DE NEGOCIO: Si la cantidad es 0, significa que ya no desea generar folios
        if (dto.getRequestedLabels() == 0) {
            if (existingRequest.isPresent()) {
                LabelRequest req = existingRequest.get();

                // Solo permitir eliminar/cancelar si NO se han generado folios aún
                if (req.getFoliosGenerados() == 0) {
                    persistence.delete(req);
                    log.info("Solicitud cancelada (cantidad=0) para producto {} en almacén {} periodo {}",
                        dto.getProductId(), dto.getWarehouseId(), dto.getPeriodId());
                } else {
                    throw new InvalidLabelStateException(
                        "No se puede cancelar la solicitud porque ya se generaron " +
                        req.getFoliosGenerados() + " folios. Debe imprimirlos primero.");
                }
            }
            // Si no existe solicitud y la cantidad es 0, no hacer nada
            return;
        }

        // REGLA DE NEGOCIO: No permitir solicitar si existen marbetes GENERADOS sin imprimir
        // Esta validación solo aplica para solicitudes NUEVAS o al INCREMENTAR la cantidad
        if (existingRequest.isPresent()) {
            LabelRequest existing = existingRequest.get();

            // Si ya se generaron folios, verificar que no haya sin imprimir
            if (existing.getFoliosGenerados() > 0) {
                boolean hasUnprinted = persistence.existsGeneratedUnprintedForProductWarehousePeriod(
                    dto.getProductId(),
                    dto.getWarehouseId(),
                    dto.getPeriodId()
                );
                if (hasUnprinted) {
                    throw new InvalidLabelStateException(
                        "Existen marbetes GENERADOS sin imprimir para este producto/almacén/periodo. " +
                        "Por favor imprima los marbetes existentes antes de solicitar más.");
                }
            }

            // REGLA DE NEGOCIO: Mientras no haya ejecutado "Generar marbetes",
            // podrá cambiar la cantidad las veces que desee
            log.info("Actualizando solicitud existente de {} a {} folios para producto {} en almacén {} periodo {}",
                existing.getRequestedLabels(), dto.getRequestedLabels(),
                dto.getProductId(), dto.getWarehouseId(), dto.getPeriodId());

            existing.setRequestedLabels(dto.getRequestedLabels());
            persistence.save(existing);

        } else {
            // CREAR nueva solicitud
            log.info("Creando nueva solicitud de {} folios para producto {} en almacén {} periodo {}",
                dto.getRequestedLabels(), dto.getProductId(), dto.getWarehouseId(), dto.getPeriodId());

            LabelRequest req = new LabelRequest();
            req.setProductId(dto.getProductId());
            req.setWarehouseId(dto.getWarehouseId());
            req.setPeriodId(dto.getPeriodId());
            req.setRequestedLabels(dto.getRequestedLabels());
            req.setFoliosGenerados(0);
            req.setCreatedBy(userId);
            req.setCreatedAt(LocalDateTime.now());

            persistence.save(req);
        }

        // REGLA DE NEGOCIO CUMPLIDA: Los datos se guardan automáticamente en BD,
        // puede cambiar de módulo sin temor a perder el dato
    }

    @Override
    @Transactional
    public tokai.com.mx.SIGMAV2.modules.labels.application.dto.GenerateBatchResponseDTO generateBatch(GenerateBatchDTO dto, Long userId, String userRole) {
        log.info("=== INICIO generateBatch ===");
        log.info("DTO recibido: productId={}, warehouseId={}, periodId={}, labelsToGenerate={}",
            dto.getProductId(), dto.getWarehouseId(), dto.getPeriodId(), dto.getLabelsToGenerate());
        log.info("Usuario: userId={}, userRole={}", userId, userRole);

        // Validar acceso al almacén
        warehouseAccessService.validateWarehouseAccess(userId, dto.getWarehouseId(), userRole);
        log.info("Acceso al almacén validado correctamente");

        // Buscar solicitud existente
        Optional<LabelRequest> opt = persistence.findByProductWarehousePeriod(dto.getProductId(), dto.getWarehouseId(), dto.getPeriodId());
        if (opt.isEmpty()) {
            log.error("No se encontró solicitud para producto={}, warehouse={}, period={}",
                dto.getProductId(), dto.getWarehouseId(), dto.getPeriodId());
            throw new LabelNotFoundException("No existe una solicitud para el producto/almacén/periodo.");
        }
        LabelRequest req = opt.get();
        log.info("Solicitud encontrada: id={}, requestedLabels={}, foliosGenerados={}",
            req.getIdLabelRequest(), req.getRequestedLabels(), req.getFoliosGenerados());

        int remaining = req.getRequestedLabels() - req.getFoliosGenerados();
        if (remaining <= 0) {
            log.error("No hay folios restantes para generar. Solicitados={}, Generados={}",
                req.getRequestedLabels(), req.getFoliosGenerados());
            throw new InvalidLabelStateException("No hay folios solicitados para generar.");
        }
        int toGenerate = Math.min(remaining, dto.getLabelsToGenerate());
        log.info("Se generarán {} marbetes (restantes={}, solicitados en lote={})",
            toGenerate, remaining, dto.getLabelsToGenerate());

        // NUEVA REGLA DE NEGOCIO: Verificar existencias del producto
        log.info("Verificando existencias del producto {} en almacén {} periodo {}",
            dto.getProductId(), dto.getWarehouseId(), dto.getPeriodId());

        Integer existencias = 0;
        try {
            var stockOpt = inventoryStockRepository
                .findByProductIdProductAndWarehouseIdWarehouseAndPeriodId(
                    dto.getProductId(), dto.getWarehouseId(), dto.getPeriodId());

            if (stockOpt.isPresent()) {
                existencias = stockOpt.get().getExistQty() != null ?
                    stockOpt.get().getExistQty().intValue() : 0;
            }
            log.info("Existencias encontradas: {}", existencias);
        } catch (Exception e) {
            log.warn("No se pudieron obtener existencias: {}", e.getMessage());
        }

        // Allocación de rango de folios (transaccional)
        long[] range = persistence.allocateFolioRange(dto.getPeriodId(), toGenerate);
        long primer = range[0];
        long ultimo = range[1];
        log.info("Rango de folios asignado: {} a {}", primer, ultimo);

        // Guardar marbetes individuales con validación de existencias
        log.info("Guardando {} marbetes en la base de datos...", toGenerate);

        int generadosConExistencias = 0;
        int generadosSinExistencias = 0;

        if (existencias > 0) {
            // Producto CON existencias - generar normalmente
            persistence.saveLabelsBatch(req.getIdLabelRequest(), dto.getPeriodId(),
                dto.getWarehouseId(), dto.getProductId(), primer, ultimo, userId);
            generadosConExistencias = toGenerate;
            log.info("Marbetes guardados exitosamente con estado GENERADO");
        } else {
            // Producto SIN existencias - crear como CANCELADO
            persistence.saveLabelsBatchAsCancelled(req.getIdLabelRequest(), dto.getPeriodId(),
                dto.getWarehouseId(), dto.getProductId(), primer, ultimo, userId, existencias);
            generadosSinExistencias = toGenerate;
            log.warn("Marbetes guardados con estado CANCELADO por falta de existencias");
        }

        // Registrar lote
        LabelGenerationBatch batch = new LabelGenerationBatch();
        batch.setLabelRequestId(req.getIdLabelRequest());
        batch.setPeriodId(dto.getPeriodId());
        batch.setWarehouseId(dto.getWarehouseId());
        batch.setPrimerFolio(primer);
        batch.setUltimoFolio(ultimo);
        batch.setTotalGenerados(toGenerate);
        batch.setGeneradoPor(userId);
        batch.setGeneradoAt(LocalDateTime.now());

        persistence.saveGenerationBatch(batch);
        log.info("Lote de generación registrado: batchId será asignado por BD");

        // Actualizar la solicitud
        int nuevosFoliosGenerados = req.getFoliosGenerados() + toGenerate;
        req.setFoliosGenerados(nuevosFoliosGenerados);
        persistence.save(req);
        log.info("Solicitud actualizada: foliosGenerados={}/{}", nuevosFoliosGenerados, req.getRequestedLabels());
        log.info("=== FIN generateBatch EXITOSO ===");

        // Construir respuesta con detalles
        String mensaje = String.format(
            "Generación completada: %d marbete(s) total. " +
            "%d con existencias (GENERADOS), %d sin existencias (CANCELADOS)",
            toGenerate, generadosConExistencias, generadosSinExistencias
        );

        return tokai.com.mx.SIGMAV2.modules.labels.application.dto.GenerateBatchResponseDTO.builder()
            .totalGenerados(toGenerate)
            .generadosConExistencias(generadosConExistencias)
            .generadosSinExistencias(generadosSinExistencias)
            .primerFolio(primer)
            .ultimoFolio(ultimo)
            .mensaje(mensaje)
            .build();
    }

    @Override
    @Transactional
    public byte[] printLabels(PrintRequestDTO dto, Long userId, String userRole) {
        log.info("Iniciando impresión de marbetes: periodId={}, warehouseId={}, startFolio={}, endFolio={}, userId={}, userRole={}",
            dto.getPeriodId(), dto.getWarehouseId(), dto.getStartFolio(), dto.getEndFolio(), userId, userRole);

        // REGLA DE NEGOCIO: Esta operación delimita el contexto según usuario y almacén asignado,
        // PERO si el usuario tiene rol "ADMINISTRADOR" o "AUXILIAR", puede cambiar de almacén
        if (userRole != null && (userRole.equalsIgnoreCase("ADMINISTRADOR") || userRole.equalsIgnoreCase("AUXILIAR"))) {
            log.info("Usuario {} tiene rol {} - puede imprimir en cualquier almacén", userId, userRole);
            // Los administradores y auxiliares pueden imprimir en cualquier almacén sin validación restrictiva
        } else {
            // Para otros roles, validar acceso estricto al almacén
            warehouseAccessService.validateWarehouseAccess(userId, dto.getWarehouseId(), userRole);
        }

        // REGLA DE NEGOCIO: Se podrán imprimir marbetes siempre y cuando se hayan importado datos
        // de los catálogos de inventario y multialmacén
        boolean hasInventoryData = inventoryStockRepository.existsByWarehouseIdWarehouseAndPeriodId(
            dto.getWarehouseId(), dto.getPeriodId());

        if (!hasInventoryData) {
            throw new tokai.com.mx.SIGMAV2.modules.labels.application.exception.CatalogNotLoadedException(
                "No se pueden imprimir marbetes porque no se han cargado los catálogos de inventario " +
                "y multialmacén para el periodo y almacén seleccionados. " +
                "Por favor, importe los datos antes de continuar.");
        }

        // REGLA DE NEGOCIO: Validar que el rango de folios sea válido
        if (dto.getStartFolio() > dto.getEndFolio()) {
            throw new InvalidLabelStateException(
                "El folio inicial no puede ser mayor que el folio final.");
        }

        // REGLA DE NEGOCIO: Verificar que los folios solicitados existan y estén generados
        long foliosCount = dto.getEndFolio() - dto.getStartFolio() + 1;
        log.info("Intentando imprimir {} folio(s) desde {} hasta {}",
            foliosCount, dto.getStartFolio(), dto.getEndFolio());

        // Obtener los marbetes del rango especificado
        List<Label> labelsToProcess = persistence.findByFolioRange(
            dto.getPeriodId(),
            dto.getWarehouseId(),
            dto.getStartFolio(),
            dto.getEndFolio()
        );

        if (labelsToProcess.isEmpty()) {
            throw new InvalidLabelStateException(
                "No se encontraron marbetes en el rango especificado");
        }

        // Validar que no haya marbetes CANCELADOS
        long cancelledCount = labelsToProcess.stream()
            .filter(l -> l.getEstado() == Label.State.CANCELADO)
            .count();

        if (cancelledCount > 0) {
            throw new InvalidLabelStateException(
                String.format("No se pueden imprimir los marbetes: %d folios están CANCELADOS", cancelledCount));
        }

        // REGLA DE NEGOCIO: Soportar dos escenarios de impresión:
        // 1. Impresión normal: Impresión inmediata de marbetes recién generados (GENERADOS)
        // 2. Impresión extraordinaria: Reimpresión de marbetes previamente impresos (IMPRESOS)

        try {
            // Marcar como impresos y registrar en la tabla label_print
            LabelPrint result = persistence.printLabelsRange(
                dto.getPeriodId(),
                dto.getWarehouseId(),
                dto.getStartFolio(),
                dto.getEndFolio(),
                userId
            );

            log.info("Impresión registrada exitosamente: {} folio(s) del {} al {}",
                result.getCantidadImpresa(), result.getFolioInicial(), result.getFolioFinal());

            // Generar el PDF con JasperReports
            log.info("Generando PDF con {} marbetes...", labelsToProcess.size());
            byte[] pdfBytes = jasperLabelPrintService.generateLabelsPdf(labelsToProcess);

            log.info("PDF generado exitosamente: {} KB", pdfBytes.length / 1024);
            return pdfBytes;

        } catch (IllegalArgumentException e) {
            log.error("Error de validación en impresión: {}", e.getMessage());
            throw new InvalidLabelStateException(e.getMessage());
        } catch (IllegalStateException e) {
            log.error("Error de estado en impresión: {}", e.getMessage());
            throw new InvalidLabelStateException(e.getMessage());
        }
    }

    @Override
    @Transactional
    public LabelCountEvent registerCountC1(CountEventDTO dto, Long userId, String userRole) {
        if (userRole == null) {
            throw new PermissionDeniedException("Role de usuario requerido para registrar C1");
        }
        String roleUpper = userRole.toUpperCase();
        boolean allowed = roleUpper.equals("ADMINISTRADOR") || roleUpper.equals("ALMACENISTA") || roleUpper.equals("AUXILIAR") || roleUpper.equals("AUXILIAR_DE_CONTEO");
        if (!allowed) {
            throw new PermissionDeniedException("No tiene permiso para registrar C1");
        }

        // Verificar que el marbete exista
        Optional<Label> optLabel = persistence.findByFolio(dto.getFolio());
        if (optLabel.isEmpty()) {
            throw new LabelNotFoundException("El folio no existe");
        }
        Label label = optLabel.get();

        // Validar acceso al almacén del marbete
        warehouseAccessService.validateWarehouseAccess(userId, label.getWarehouseId(), userRole);

        if (label.getEstado() == Label.State.CANCELADO) {
            throw new InvalidLabelStateException("No se puede registrar conteo: el marbete está CANCELADO.");
        }
        if (label.getEstado() != Label.State.IMPRESO) {
            throw new InvalidLabelStateException("No se puede registrar conteo: el marbete no está IMPRESO.");
        }

        // No permitir registrar C1 si ya existe C1
        if (persistence.hasCountNumber(dto.getFolio(), 1)) {
            throw new DuplicateCountException("El conteo C1 ya fue registrado para este folio.");
        }
        // No permitir registrar C1 si ya existe C2 (secuencia rota)
        if (persistence.hasCountNumber(dto.getFolio(), 2)) {
            throw new CountSequenceException("No se puede registrar C1 porque ya existe un conteo C2 para este folio.");
        }

        LabelCountEvent.Role roleEnum;
        try { roleEnum = LabelCountEvent.Role.valueOf(roleUpper); } catch (Exception ex) { roleEnum = LabelCountEvent.Role.AUXILIAR; }

        return persistence.saveCountEvent(dto.getFolio(), userId, 1, dto.getCountedValue(), roleEnum, false);
    }

    @Override
    @Transactional
    public LabelCountEvent registerCountC2(CountEventDTO dto, Long userId, String userRole) {
        if (userRole == null) {
            throw new PermissionDeniedException("Role de usuario requerido para registrar C2");
        }
        String roleUpper = userRole.toUpperCase();
        if (!roleUpper.equals("AUXILIAR_DE_CONTEO")) {
            throw new PermissionDeniedException("No tiene permiso para registrar C2");
        }

        // Verificar que el marbete exista
        Optional<Label> optLabel = persistence.findByFolio(dto.getFolio());
        if (optLabel.isEmpty()) {
            throw new LabelNotFoundException("El folio no existe");
        }
        Label label = optLabel.get();

        // Validar acceso al almacén del marbete
        warehouseAccessService.validateWarehouseAccess(userId, label.getWarehouseId(), userRole);

        if (label.getEstado() == Label.State.CANCELADO) {
            throw new InvalidLabelStateException("No se puede registrar conteo: el marbete está CANCELADO.");
        }
        if (label.getEstado() != Label.State.IMPRESO) {
            throw new InvalidLabelStateException("No se puede registrar conteo: el marbete no está IMPRESO.");
        }

        // Debe existir C1 antes de C2
        if (!persistence.hasCountNumber(dto.getFolio(), 1)) {
            throw new CountSequenceException("No se puede registrar C2 porque no existe un conteo C1 previo.");
        }

        // No permitir duplicar C2
        if (persistence.hasCountNumber(dto.getFolio(), 2)) {
            throw new DuplicateCountException("El conteo C2 ya fue registrado para este folio.");
        }

        LabelCountEvent.Role roleEnum;
        try { roleEnum = LabelCountEvent.Role.valueOf(roleUpper); } catch (Exception ex) { roleEnum = LabelCountEvent.Role.AUXILIAR_DE_CONTEO; }

        return persistence.saveCountEvent(dto.getFolio(), userId, 2, dto.getCountedValue(), roleEnum, true);
    }

    @Override
    @Transactional
    public LabelCountEvent updateCountC1(tokai.com.mx.SIGMAV2.modules.labels.application.dto.UpdateCountDTO dto, Long userId, String userRole) {
        log.info("Actualizando conteo C1 para folio {}", dto.getFolio());

        if (userRole == null) {
            throw new PermissionDeniedException("Role de usuario requerido para actualizar C1");
        }

        String roleUpper = userRole.toUpperCase();
        boolean allowed = roleUpper.equals("ADMINISTRADOR") || roleUpper.equals("ALMACENISTA") ||
                         roleUpper.equals("AUXILIAR") || roleUpper.equals("AUXILIAR_DE_CONTEO");
        if (!allowed) {
            throw new PermissionDeniedException("No tiene permiso para actualizar C1");
        }

        // Verificar que el marbete exista
        Optional<Label> optLabel = persistence.findByFolio(dto.getFolio());
        if (optLabel.isEmpty()) {
            throw new LabelNotFoundException("El folio no existe");
        }
        Label label = optLabel.get();

        // Validar acceso al almacén del marbete
        warehouseAccessService.validateWarehouseAccess(userId, label.getWarehouseId(), userRole);

        if (label.getEstado() == Label.State.CANCELADO) {
            throw new InvalidLabelStateException("No se puede actualizar conteo: el marbete está CANCELADO.");
        }
        if (label.getEstado() != Label.State.IMPRESO) {
            throw new InvalidLabelStateException("No se puede actualizar conteo: el marbete no está IMPRESO.");
        }

        // Buscar el evento de conteo C1 existente
        List<LabelCountEvent> events = jpaLabelCountEventRepository.findByFolioOrderByCreatedAtAsc(dto.getFolio());
        LabelCountEvent eventC1 = events.stream()
            .filter(e -> e.getCountNumber() == 1)
            .findFirst()
            .orElseThrow(() -> new LabelNotFoundException("No existe un conteo C1 para actualizar"));

        // Actualizar el valor
        eventC1.setCountedValue(dto.getCountedValue());

        LabelCountEvent updated = jpaLabelCountEventRepository.save(eventC1);
        log.info("Conteo C1 actualizado exitosamente para folio {}", dto.getFolio());

        return updated;
    }

    @Override
    @Transactional
    public LabelCountEvent updateCountC2(tokai.com.mx.SIGMAV2.modules.labels.application.dto.UpdateCountDTO dto, Long userId, String userRole) {
        log.info("Actualizando conteo C2 para folio {}", dto.getFolio());

        if (userRole == null) {
            throw new PermissionDeniedException("Role de usuario requerido para actualizar C2");
        }

        String roleUpper = userRole.toUpperCase();
        // Para C2, permitir actualización a ADMINISTRADOR y AUXILIAR_DE_CONTEO
        boolean allowed = roleUpper.equals("ADMINISTRADOR") || roleUpper.equals("AUXILIAR_DE_CONTEO");
        if (!allowed) {
            throw new PermissionDeniedException("No tiene permiso para actualizar C2. Solo ADMINISTRADOR o AUXILIAR_DE_CONTEO pueden actualizar el segundo conteo.");
        }

        // Verificar que el marbete exista
        Optional<Label> optLabel = persistence.findByFolio(dto.getFolio());
        if (optLabel.isEmpty()) {
            throw new LabelNotFoundException("El folio no existe");
        }
        Label label = optLabel.get();

        // Validar acceso al almacén del marbete
        warehouseAccessService.validateWarehouseAccess(userId, label.getWarehouseId(), userRole);

        if (label.getEstado() == Label.State.CANCELADO) {
            throw new InvalidLabelStateException("No se puede actualizar conteo: el marbete está CANCELADO.");
        }
        if (label.getEstado() != Label.State.IMPRESO) {
            throw new InvalidLabelStateException("No se puede actualizar conteo: el marbete no está IMPRESO.");
        }

        // Buscar el evento de conteo C2 existente
        List<LabelCountEvent> events = jpaLabelCountEventRepository.findByFolioOrderByCreatedAtAsc(dto.getFolio());
        LabelCountEvent eventC2 = events.stream()
            .filter(e -> e.getCountNumber() == 2)
            .findFirst()
            .orElseThrow(() -> new LabelNotFoundException("No existe un conteo C2 para actualizar"));

        // Actualizar el valor
        eventC2.setCountedValue(dto.getCountedValue());

        LabelCountEvent updated = jpaLabelCountEventRepository.save(eventC2);
        log.info("Conteo C2 actualizado exitosamente para folio {}", dto.getFolio());

        return updated;
    }
    @Override
    @Transactional(readOnly = true)
    public List<LabelSummaryResponseDTO> getLabelSummary(LabelSummaryRequestDTO dto, Long userId, String userRole) {
        log.info("getLabelSummary - Inicio: periodId={}, warehouseId={}, page={}, size={}, searchText={}, sortBy={}, sortDirection={}, userId={}, userRole={}",
            dto.getPeriodId(), dto.getWarehouseId(), dto.getPage(), dto.getSize(),
            dto.getSearchText(), dto.getSortBy(), dto.getSortDirection(), userId, userRole);
        return new ArrayList<>();
    }
    @Override
    @Transactional(readOnly = true)
    public long countLabelsByPeriodAndWarehouse(Long periodId, Long warehouseId) {
        return 0;
    }
    @Override
    @Transactional(readOnly = true)
    public tokai.com.mx.SIGMAV2.modules.labels.application.dto.LabelStatusResponseDTO getLabelStatus(Long folio, Long periodId, Long warehouseId, Long userId, String userRole) {
        return null;
    }
    @Override
    public void generateBatchList(GenerateBatchListDTO dto, Long userId, String userRole) {
    }
    @Override
    @Transactional(readOnly = true)
    public List<tokai.com.mx.SIGMAV2.modules.labels.application.dto.LabelCancelledDTO> getCancelledLabels(Long periodId, Long warehouseId, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional
    public tokai.com.mx.SIGMAV2.modules.labels.application.dto.LabelCancelledDTO updateCancelledStock(tokai.com.mx.SIGMAV2.modules.labels.application.dto.UpdateCancelledStockDTO dto, Long userId, String userRole) {
        return null;
    }
    @Override
    @Transactional(readOnly = true)
    public List<tokai.com.mx.SIGMAV2.modules.labels.application.dto.LabelDetailDTO> getLabelsByProduct(Long productId, Long periodId, Long warehouseId, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional
    public void cancelLabel(CancelLabelRequestDTO dto, Long userId, String userRole) {
    }
    @Override
    @Transactional(readOnly = true)
    public tokai.com.mx.SIGMAV2.modules.labels.application.dto.LabelForCountDTO getLabelForCount(Long folio, Long periodId, Long warehouseId, Long userId, String userRole) {
        return null;
    }
    @Override
    @Transactional(readOnly = true)
    public List<tokai.com.mx.SIGMAV2.modules.labels.application.dto.LabelForCountDTO> getLabelsForCountList(Long periodId, Long warehouseId, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional(readOnly = true)
    public List<DistributionReportDTO> getDistributionReport(ReportFilterDTO filter, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional(readOnly = true)
    public List<LabelListReportDTO> getLabelListReport(ReportFilterDTO filter, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional(readOnly = true)
    public List<PendingLabelsReportDTO> getPendingLabelsReport(ReportFilterDTO filter, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional(readOnly = true)
    public List<DifferencesReportDTO> getDifferencesReport(ReportFilterDTO filter, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional(readOnly = true)
    public List<CancelledLabelsReportDTO> getCancelledLabelsReport(ReportFilterDTO filter, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional(readOnly = true)
    public List<ComparativeReportDTO> getComparativeReport(ReportFilterDTO filter, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional(readOnly = true)
    public List<WarehouseDetailReportDTO> getWarehouseDetailReport(ReportFilterDTO filter, Long userId, String userRole) {
        return new ArrayList<>();
    }
    @Override
    @Transactional(readOnly = true)
    public List<ProductDetailReportDTO> getProductDetailReport(ReportFilterDTO filter, Long userId, String userRole) {
        return new ArrayList<>();
    }
}
